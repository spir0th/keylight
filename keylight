#!/bin/sh
# keylight - A small shell script that turns on/off keyboard backlights.
# Copyleft (C) 2023 spirothXYZ, all rights reserved

# Store name of command to modify LED value
MODIFIER_COMMAND_ARGS_ON="led 3"
MODIFIER_COMMAND_ARGS_OFF="-led 3"
MODIFIER_COMMAND_ARGS=$MODIFIER_COMMAND_ARGS_OFF
MODIFIER_COMMAND="xset"

# Store LED path to determine input device
LED_PATH_PREFIX="/sys/class/leds/input"
LED_PATH_SUFFIX="::scrolllock/brightness"
LED_PATH_COUNT=1
LED_PATH_COUNT_MAX=1000
LED_PATH="${LED_PATH_PREFIX}${LED_PATH_COUNT}${LED_PATH_SUFFIX}"

# Store name of the environment session (e.g wayland, x11, tty)
ENV_SESSION=$(loginctl show-session 2 -p Type)

# Store argument variables (e.g PRINT_HELP_INFO, PRINT_VERBOSE_INFO)
ALLOW_NON_X11_SESSION="no"
PRINT_HELP_INFO="no"
PRINT_VERBOSE_INFO="no"

# Parse command-line arguments for utility variables
for i in "$@"; do
    if [ $i == "--no-x11" ]; then
        ALLOW_NON_X11_SESSION="yes"
    fi
    if [ $i == "-h" ] || [ $i == "--help" ]; then
        PRINT_HELP_INFO="yes"
    fi
    if [ $i == "-v" ] || [ $i == "--verbose" ]; then
        PRINT_VERBOSE_INFO="yes"
    fi
done

# If PRINT_HELP_INFO is set to yes then print help information and exit
if [ $PRINT_HELP_INFO == "yes" ]; then
    echo "Usage: $(basename "$(test -L "$0" && readlink "$0" || echo "$0")") [OPTIONS...] "
    echo
    echo "Options:"
    echo "  --no-x11: Run without checking X11"
    echo "  --help: Print help information then exit"
    echo "  --verbose: Print detailed information for advanced users"
    exit 0
fi

# Detect if running in X11, otherwise, exit
# To disable this check, pass --no-x11 in the arguments
if [ ${ENV_SESSION#*=} != "x11" ] && [ $ALLOW_NON_X11_SESSION != "yes" ]; then
    echo "This program requires X11."
    exit 1
fi

# Iterate until the correct LED path is found
while [ ! -f $LED_PATH ];
do
    if [ $PRINT_VERBOSE_INFO == "yes" ]; then
        echo "${LED_PATH} does not exist, incrementing."
    fi
    if [ $LED_PATH_COUNT -gt $LED_PATH_COUNT_MAX ]; then
        if [ $PRINT_VERBOSE_INFO == "yes" ]; then
            echo "Path incremental count has reached max limits. Stopping."
        fi

        break
    fi

    LED_PATH_COUNT=$((LED_PATH_COUNT + 1))
    LED_PATH="${LED_PATH_PREFIX}${LED_PATH_COUNT}${LED_PATH_SUFFIX}"
done

# If the LED path cannot be resolved, then exit.
if [ ! -f $LED_PATH ]; then
    echo "No input device with LED backlights found."
    exit 1
fi

# DEBUG: Print the correct LED path
if [ $PRINT_VERBOSE_INFO == "yes" ]; then
        echo "${LED_PATH} found."
fi

# Read the value of LED path to determine state
LED_STATE=$(cat $LED_PATH)

# Turn on/off LED backlight on keyboard depending on the stored state
if [ $LED_STATE -lt 1 ]; then
    # LED backlight is turned off, turn it on.
    if [ $PRINT_VERBOSE_INFO == "yes" ]; then
        echo "Value returned 0 from ${LED_PATH}"
        echo "Setting value 1 to ${LED_PATH}"
    fi

    MODIFIER_COMMAND_ARGS=$MODIFIER_COMMAND_ARGS_ON
elif [ $LED_STATE -gt 0 ]; then
    # LED backlight is already turned on, turn it off.
    if [ $PRINT_VERBOSE_INFO == "yes" ]; then
        echo "Value returned 1 from ${LED_PATH}"
        echo "Setting value 0 to ${LED_PATH}"
    fi

    MODIFIER_COMMAND_ARGS=$MODIFIER_COMMAND_ARGS_OFF
fi

# Make sure the command modifier is valid before executing
if [ ! command -v ${MODIFIER_COMMAND} &>/dev/null ]; then
    echo "${MODIFIER_COMMAND} does not exist / or is not a valid command."
    exit 127
fi

exec ${MODIFIER_COMMAND} ${MODIFIER_COMMAND_ARGS}

